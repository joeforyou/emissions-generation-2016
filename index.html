<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v5.min.js"></script>
<link rel="stylesheet" href="css/style.css" type="text/css">
</head>
<body>
    <header>
        <h1>US Map showing eGRID 2016 Data</h1>
        <select id="selectParameter"></select>
    </header>
<script type="text/javascript">

// Helper function to convert numbers with commas to integers
function strToInt(str) {
    if (str !== "--") {
        return parseFloat(str.replace(/,/g,''),10) 
    } else {
        return 0;
    }
}
// Helper function to find rounded max
function roundMax(num) {
    if(num !== "--"){
        var z = num.toString().length - 1
        var exp = Math.pow(10,z)
        return Math.ceil(num / exp) * exp  
    } else {
        return 0;
    }
}
function findTickValues(num) {
    return d3.range(num / 10, num, num / 10)
}
function findTickFormat(max) {
    var str = "1e" + max.toString().length - 2;
    return parseInt(str);
}
function findUnits(str) {
    return str.match(/\(([^)]+)\)/)[1];
}
function numberWithCommas (x) {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

//Width and height of map
var width = 1000;
var height = 500;

// D3 Projection
var projection = d3.geoAlbersUsa()
				   .translate([width/2, height/2])    // translate to center of screen
				   .scale([1000]);          // scale things down so see entire US
        
// Define path generator
var path = d3.geoPath()               // path generator that will convert GeoJSON to SVG paths
		  	 .projection(projection);  // tell path generator to use albersUsa projection

var color = d3.scaleLinear()

// Load in my states data!
var csvData;
var max_nameplate;
var roundedUp;
var dataDefs;
var units;
var select = document.getElementById("selectParameter");

d3.csv("/data/egrid2016_defs.csv", function(d) {
    return d;
}).then( function(data){
    dataDefs = data[0];
    for (var key in dataDefs) {
        if (key !== "PSTATABB" && key !== "FIPSST"){
            var option = document.createElement("option");
            option.text = dataDefs[key];
            option.value = key;
            select.appendChild(option);
        }
    }
});

select.addEventListener("change", function() {
    var currentSelection = select.value;
    console.log(currentSelection)
    units = findUnits(dataDefs[currentSelection]);
    var param = currentSelection;
    paintMap(param);
});

d3.csv("/data/egrid2016_states.csv", function(d) {
    return d;
}).then(function(data) {
    csvData = data;
    max_nameplate = d3.max( data, function(d) { return strToInt(d.NAMEPCAP); });
    roundedUp = roundMax(max_nameplate)
    units = findUnits(dataDefs["NAMEPCAP"])
    color.domain([0, roundedUp]).range(["#ffffb2","#bd0026"]);
});

function paintMap(param){
    // Delete all
    if(!d3.selectAll("svg").empty()){
        d3.selectAll("svg").remove();
        var max = d3.max( csvData, function(d) { return strToInt(d[param]); });
        roundedUp = roundMax(max)
        color.domain([0, roundedUp]).range(["#ffffb2","#bd0026"]);
    }
    
    //Create SVG element and append map to the SVG
    var svg = d3.select("body")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

    // Tooltip
    var tooltip = d3.select("body").append("div") 
        .attr("class", "tooltip")       
        .style("opacity", 0);

    // Load GeoJSON data and merge with states data
    d3.json("/data/us-states.json").then(function(json) {
    // Loop through each state data value in the .csv file
    for (var i = 0; i < csvData.length; i++) {
        // Grab State Name
        var dataState = csvData[i].PSTATABB;
        // Grab data value 
        var dataValue = strToInt(csvData[i][param]);
        //console.log(dataValue)
        // Find the corresponding state inside the GeoJSON
        for (var j = 0; j < json.features.length; j++)  {
            var jsonState = json.features[j].properties.name;
            if (dataState == jsonState) {
            // Copy the data value into the JSON
                json.features[j].properties[param] = dataValue; 
            // Stop looking through the JSON
            break;
            }
        }
    }
    // Bind the data to the SVG and create one path per GeoJSON feature
    svg.selectAll("path")
        .data(json.features)
        .enter()
        .append("path")
        .attr("d", path)
        .style("stroke", "#a9a9a9")
        .style("stroke-width", "1")
        .on("mouseover", function(d) {    
            tooltip.transition()    
            .duration(200)    
            .style("opacity", .9);    
            tooltip.html(d.properties.name + "<br>" + numberWithCommas(d.properties[param]) + " " + units)  
            .style("left", (d3.event.pageX) + "px")   
            .style("top", (d3.event.pageY - 28) + "px");  
          })          
          .on("mouseout", function(d) {   
            tooltip.transition()    
            .duration(500)    
            .style("opacity", 0); 
          })
        .style("fill", function(d) {
        // Get data value
        var value = d.properties[param];
        if (value) {
        //If value exists…
            return color(value);
        } else {
        //If value is undefined…
        return "rgb(213,222,217)";
        }
    });
    var svgGradient = d3.select("body")
                            .append("svg")
                            .style("margin-left","300px")

    // append title
    svgGradient.append("text")
      .attr("class", "legendTitle")
      .attr("x", 0)
      .attr("y", 60)
      .style("text-anchor", "left")
      .text(dataDefs[param]);

    var defs = svgGradient.append("defs");

    var linearGradient = defs.append("linearGradient")
                                .attr("class","legend")
                                .attr("id","linear-gradient")

    linearGradient
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "100%")
        .attr("y2", "0%");

    linearGradient.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "#ffffb2")
    //Set the color for the end (100%)
    linearGradient.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", "#bd0026");

    svgGradient.append("rect")
        .attr("width", 400)
        .attr("height", 20)
        .style("fill", "url(#linear-gradient)");

    // create tick marks
    var xLeg = d3.scaleLinear()
                    .domain(color.domain())
                    .range([0,400]);

    if (param == "NAMEPCAP"){
        var axisLeg = d3.axisBottom(xLeg)
            .tickSize(10)
            .tickValues(findTickValues(roundedUp))
            .tickFormat(d3.formatPrefix(".0s", findTickFormat(max_nameplate)));
    } else {
        var axisLeg = d3.axisBottom(xLeg)
            .tickSize(10)
            .tickValues(findTickValues(roundedUp))
            .tickFormat(d3.formatPrefix(".1s", findTickFormat(max)));
    }

    if(max == 0) {
        svgGradient.attr("display","none")
      }

    svgGradient
      .attr("class", "axis")
      .append("g")
      .attr("transform", "translate(0, 20)")
      .call(axisLeg);

    }).catch(function(error) {
        console.log(error)
    });   
}

paintMap("NAMEPCAP")


</script>
</body>
</html>